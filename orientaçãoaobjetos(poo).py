# -*- coding: utf-8 -*-
"""OrientaçãoAObjetos(POO).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bh7Qv7irfI--4VnthB1p1zo2gPpIZ0Gp

# O que é orientação orientada a objetos

- Programação orientada a objetos (POO) é um paradigma de programação que se baseia no conceito de 'Objetos', que são entidades que possuem caracteristicas (atributos) e comportamentos(métodos). Em POO, o foco está na criação de objetos que integram entre si para realizar tarefas.

- A POO tem como principio a encapsulação, que é a capacidades de um objeto de ocultar seus detalhes internos e expor apenas o necessario para interagir com os outros oobjetos. Além disso, a POO tambem se basea em herança e polimorfismo, que permite a reutilização de código e a criação de hieraquias de classes que representam conceitos e objetos mais abstratos.

- POO tambem é o paradigma de programação comummente usado para construir algoritmos de Marchine Learning.

# Classes

- Em programação orientado a objetos(POO), uma classe é uma estrutura que descreve um objeto, especificando os atributos e comportamentos que o objeto deve ter. Uma classe é uma espécie de modelo que define as caracteristicas e ações que um objeto deve possuir.

- As classes são usadas para criar objetos, que são instancias da classe. Cada objeto criado a partir da mesma classe terá os mesmo atributos e comportamentos.

- Para criar uma classe em Python, utiliza-se a palavra reservada classe.

- o nome da classe segue a mesma convenção de nomes para a criação de funções e variáveis em Python, mas normalmente se usa a primeira letra em maiúscula em cada palavra no nome da classe.
"""

# Criando uma classe chamada Livro:
class Livro:

  # Este método vai inicializar cada objeto criando a apartir desta classe.
  # O nome deste modulo é __init__
  # (self) é uma referencia a cada atributo de própria classe (e não de uma classe mãe, por exemplo)

  def __init__(self):

    #atributos sao propriedades:
    self.titulo = 'Sapiena - Uma brava historia de humanidade'
    self.isbn = 9988888
    print('Construtor chamado para criar um objeto desta classe.')

  # Métodos são funções que execultam ações nos objetos da classe.
  def imprime(self):
    print(f'Foi criado o livro {self.titulo} com o isbn {self.isbn}')

# Cria uma instancia da classe Livro
livro1 = Livro()

type(livro1)

livro1.titulo

livro1.isbn

livro1.imprime()

class Livro():
    def __init__(self, titulo, isbn):
      self.titulo = titulo
      self.isbn = isbn
      print('Construtor chamado para criar um objeto desta classe.')

    def imprime(self, titulo, isbn):
     print(f'Foi criado o livro {self.titulo} com o isbn {self.isbn}')

livro1 = Livro('Sapiena - Uma brava historia de humanidade', 9988888)
livro2 = Livro('Monge e o execultivo', 9988889)

livro1.titulo

livro2.titulo

class Algoritmo():
  def __init__(self, tipo_algoritmo):
    self.tipo_algoritmo = tipo_algoritmo
    print('Construtor chamado para criar um objeto desta classe.')

  def imprime(self):
    print(f'Foi criado o algoritmo {self.tipo_algoritmo}')

algoritmo1 = Algoritmo('Machine Learning')
algoritmo2 = Algoritmo('Deep Learning')

algoritmo1.tipo_algoritmo

algoritmo2.tipo_algoritmo

"""### Manipulando atributos em Python"""

class Funcionarios():
  def __init__(self, nome,salario,cargo):
    self.nome = nome
    self.salario = salario
    self.cargo = cargo
    print('Construtor criado')

    def listarFuncionarios(self):
      print(f'Funcionario(a) {self.nome}, tem o salario de R${self.salario}, e o cargo é {self.cargo}')

funcionario01 = Funcionarios('Alex',5200,'Data Scientist')

# Verifique se tem o determindo atributo nome:
hasattr(funcionario01,'nome')

# Mude o atributo de funcionario01 como o nome alex, para alexandre:
setattr(funcionario01,'nome','Alexandre')
funcionario01.nome

# pegue o atributo salario:
getattr(funcionario01,'salario')

delattr(funcionario01,'salario')

hasattr(funcionario01,'salario')

"""# Trabalhando com métodos de classe em python

- Em python, os metodos de classe são funções definidas dentro de uma classe, que realizam operações especificas em objetos criados a partir dessa classe. Os métodos de classes são unidos para implementar o comportamento dos objetos que pertencem a essa classe.

- O método init é um modelo especial que é chamado quando um objeto é criado a aprtir da classe. Este método é usuado para inciar os atributos do objeto. Outros podem ser definidos para execultar tarefas especiais em um objeto, como calcular valores, realizar operações de entrada e saida, o interator o estado do objeto.
"""

class Circulo():

  # O valor de pi é constante
  pi = 3.14

  # Quando um obejto desta classe for criado, este método será execultado e o valor default do raio será 5.
  def __init__(self, raio = 5):
    self.raio = raio
    print('construtor execultado !')

  #Este metodo caulcula a area:
  def area(self):
    return (self.raio * self.raio) * Circulo.pi

  #Metodo para gerar um novo raio
  def setRaio(self,novo_raio):
    self.raio = novo_raio

  # Métodos para gerar um novo raio
  def getRaio(self):
    return self.raio

# Criando o objeto circ, uma instancia da classe Circulo()
circulo1 = Circulo()

#Excultando um método de Circulo
circulo1.getRaio()

# Criando outro onjeto chamado circulo2. Uma instacia da classe Circulo()
# Agora descrevendo o valor do atributo.
circulo2 = Circulo(7)

circulo2.getRaio()

#Imprime o raio
print(f'O raio do circulo é {circulo2.area()}')

"""# Herança em Python"""

- Em programação Orientado a Objetos(POO), a herança é um conceito que permite criar novas classes a partir de outros classes existentes, aproveitando atributos e m étodos original e adicionado novos atributos e métodos especificos.

- A classe original é chamada de classe mãe ou superclasse e a classe chamada filha ou subclasse.

- A herança é uma tecnica importante em POO porque permite reutilizar o código de maneria mais eficiente. Em vez de criara uma nova classe do zero. a subclasse pode herdar todos os atributos e métodos da superclasse e adicionar apenas o que é necessario. Dessa forma subclasse pode se concentrar em frnecer funcionalidades adicionais sem precisar se preocupar com as caracteristicas basicas da classe.

- Na herança, uma subclasse pode herdar os atributos e métodos da superclasse e substitui-los ou estendelos conforme o necessario. Por exemplo, uma subclasse por ter um metodo com o mesmo nome de um método da super classe, mas com um comportamento diferente.


# Criando a classe Animal - super-classe (mãe)
class Animal():
  def __init__(self):
    print('Objeto Animal criado !')

  def imprimir(self):
    print('Este é o animal')

  def comer(self):
    print('Hora de comer')

  def emitir_som(self):
    #Quando adicionamos o pass indica que dentro do método não existe nada e que o sistema pode seguir.
    pass

animal1 = Animal()

# Criando a classe Cachorro - sub-classe (filho)

#Cachorro vai ser uma classe filha de Animal ou seja dentro dos (Animal) vai definir os atributos de onde vai herdar.
class Cachorro(Animal):

  def __init__(self):
    Animal.__init__(self)
    print('Objeto cachorro criado.')

  def emitir_som(self):
    print('Au Au')

cachorro1 = Cachorro()

class Gato(Animal):

  def _init__(self):
    Animal.__init__(self)
    print('Objeto gato criado !')

  def emitir_som(self):
    print('Miau Miua !')

gato1 = Gato()

# Polimorfismo

- Polimorfismo é um dos conceitos fundamentais de programação Orientada a Objetos(POO). O polimorfismo permite que objetos de diferentes classes possam ser tratados de forma uniforme. Isso significa que um objeto pode ser tratado como se fosse um objeto de uma superclasse, mesmo que ele seja de uma subclasse.

- Mais especificamente, o polimorfismo se refere á habilidade de um objeto responder de diferentes formas a mesma mensagem, isso é possivel porque as subclasses podem implementar métodos com o mesmo nome que os métodos de superclasse, mas com comportamentos diferentes.

- Com o polimorfismo, os mesmo atributos e métodos podem ser utilizados em objetos, porém, com implementações lógicas diferentes.

# Superclass

class Veiculo():

  def __init__(self, marca, modelo):
    self.marca = marca
    self.modelo = modelo
  
  def acelerar(self):
    pass

  def frear(self):
    pass

#Subclass

class Carro(Veiculo):

  def acelerar(self):
    print('O carro esta acelerando')

  def frear(self):
    print('O carro esta freando')

#Subclass

class Aviao(Veiculo):

  def acelerar(self):
    print('O avião esta acelerando')

  def frear(self):
    print('O avião esta freando')

  def decolar(self):
    print('O avião esta decolando')

# Cria os objetos
lista_veiculos = [
    Carro('Porche','911'),
    Moto('Honda','CBR'),
    Aviao('Airbus','A320')
]

#Loop no incide de cada objeto

for item in lista_veiculos:
  item.acelerar()
  item.frear()
  if isinstance(item,Aviao):
    item.decolar()

  print('-'*3)






